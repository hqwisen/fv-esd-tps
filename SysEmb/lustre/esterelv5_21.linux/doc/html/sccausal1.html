<!-- manual page source format generated by PolyglotMan v3.0.3a12, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>sccheck(1) manual page</TITLE>
</HEAD>
<BODY>
<A HREF="#toc">Table of Contents</A><P>
 
<H2><A NAME="sect0" HREF="#toc0">NAME </A></H2>
sccheck, sccausal - Causal analysis of ESTEREL programs - Version 
v5_21  
<H2><A NAME="sect1" HREF="#toc1">SYNOPSIS </A></H2>
<B>sccheck</B> [options] file ... <P>
 <B>sccausal</B> [options] file ...  
<H2><A NAME="sect2" HREF="#toc2">DESCRIPTION 
</A></H2>
<B>sccheck </B> checks whether a program in <B>sc </B> code is constructive, and, if 
yes, checks that no single signal can be emitted more than once.  The <B>sccheck 
</B> processor does not generate code. It is normally called via the <B>esterel 
</B> command with the <B>-Icheck </B> option. <P>
<B>sccausal </B> is the full Esterel constructiveness 
analyzer. It reads a program in <B>sc </B> code, checks it for constructiveness, 
and, if it is found constructive, produces a sorted circuit code in <B>ssc 
</B> format. The <B>sccausal </B> processor is normally called via the <B>esterel </B> command 
with the <B>-causal </B> option. <P>
The <B>sccheck </B> command is equivalent to <B>sccausal 
</B> -s -single. <P>
Constructiveness analysis is necessary because Esterel programs 
can have cyclic dependencies, which translate to combinationally cyclic 
Boolean control circuits. For more information on constructiveness,  see 
the Esterel v5 documentation. <P>
The <B>sccausal </B> algorithm begins with the FSM 
representing the control of an Esterel program.  It breaks all combinational 
cycles and assigns unknown values to each circuit node and each input 
corresponding to a broken cycle. It uses the reached state set to perform 
an incremental TVF (three-valued functions) computation: the reached states 
are computed at the same time as the TVFs, at each iteration.  We begin 
by computing the TVFs for the network given the initial state, and at 
each iteration (each pass through the network), we compute the new TVFs 
given the current state set (using the cofactor operation), and we use 
these TVFs to compute the next state set.  The iteration continues until 
no new states are found, or until an unstable state is reached.  The final 
FSM, which is functionally equivalent to the original but contains no 
combinational cycles, is written in <B>ssc </B> code. <P>
 <P>
Error messages and warnings 
are written to the standard error stream. Typical use is:  
<DL>

<DT><B>esterel -Icheck 
foo.strl</B>  </DT>
<DD></DD>
</DL>
<P>
which performs the following call: 
<DL>

<DT><B></B> sccheck &lt; foo.strl  </DT>
<DD></DD>
</DL>
<P>
or 
<DL>

<DT><B>sccausal 
&lt; game1.sc &gt; game.ssc</B>  </DT>
<DD></DD>
</DL>
<P>
or equivalently  
<DL>

<DT><B>sccausal game2.sc -B game</B>  </DT>
<DD></DD>
</DL>
<P>
  
<H2><A NAME="sect3" HREF="#toc3">OPTIONS 
</A></H2>
The following options are common to all Esterel processors. 
<DL>

<DT><B>-version </B> </DT>
<DD>Print 
the version name on the standard error output stream and terminate, ignoring 
all other arguments. </DD>
</DL>
<P>
 
<DL>

<DT><B>-info </B> </DT>
<DD>Display various information about the current 
<B>sccausal </B> processor on the standard error output stream and terminate, 
ignoring all other arguments. </DD>
</DL>
<P>
 
<DL>

<DT><B>-access </B> </DT>
<DD>Print access rights to the processor 
on the standard error output stream and terminate, ignoring all other 
arguments. </DD>
</DL>
<P>
 
<DL>

<DT><B>-stat </B> </DT>
<DD>Print statistics on the standard error stream: CPU times 
required for parsing the input and  performing the causal analysis; physical 
memory requirement for the process. <I>(Not implemented in current version) 
</I>. </DD>
</DL>
<P>
 
<DL>

<DT><B>-s </B> </DT>
<DD>Silent mode: perform parsing and causality analysis but do not produce 
the <B>ssc </B> code. </DD>
</DL>
<P>
 
<DL>

<DT><B>-v </B> </DT>
<DD>Verbose mode. </DD>
</DL>
<P>
 <P>
The following option performs the analysis 
of the static cycles of the <B>sc </B> program. 
<DL>

<DT><B>-cycles </B> </DT>
<DD>Performs a topological 
sort of the oriented graph corresponding to the <B>sc </B> description. If there 
are non-trivial strongly connected components (SCC) then it prints an error 
message giving the coordinates of each SCC and the names of signals that 
close that particular SCC. If the XES call was not canceled by the user, 
the error is then shown using the XES interface. </DD>
</DL>
<P>
 <P>
The following options 
control the algorithm for causality analysis. 
<DL>

<DT><B>-cofactor </B> </DT>
<DD>Use a priori information 
about the reachable states to simplify the BDDs using the cofactor BDD 
operation.  The a priori information is derived from both the relations 
specified in the Esterel program and information internally derived about 
mutually exclusive register values. (The latter comes from the <B>selectinc 
</B> wires; see sc6 format description.)  The TVFs for the   input signals 
are cofactored with respect to this information, and the TVFs for the 
remaining nodes in the network are computed in topological order; no further 
cofactoring is necessary since the cofactor operation is transitive. </DD>
</DL>
<P>
 
<DL>

<DT><B>-restrict 
</B> </DT>
<DD>Use a priori information about the reachable states to simplify the BDDs 
using the BDD restrict operation.  Note that since the restrict operation 
is not transitive, it must be applied to each node after the TVF is computed. 
</DD>
</DL>
<P>
 
<DL>

<DT><B>-no_inc </B> </DT>
<DD>This options computes the TVFs first and then the reachable state 
space. It iteratively computes the TVFs (three-valued functions) for each 
node in the network in topological order, and substitutes the appropriate 
functions for the cut-cycle inputs.  The iteration is repeated until no 
TVFs change. The set of <B>unstable states </B> is then computed as the set of 
states in which some node has an undefined value.  The circuit is then 
momentarily assumed constructive, a combinationally-acyclic version is 
created from the TVFs, and the reachable state set for this FSM is computed. 
 The circuit is declared to be constructive if no unstable state is reached 
during the reachable state computation. </DD>
</DL>
<P>
 
<DL>

<DT><B>-inc </B> </DT>
<DD>Use the reached state set 
to perform an incremental TVF computation: the reached states are computed 
at the same time as the TVFs, at each iteration.  We begin by computing 
the TVFs for the network given the initial state, and at each iteration 
(each pass through the network), we compute the new TVFs given the current 
state set (using the cofactor operation), and we use these TVFs to compute 
the next state set.  The iteration continues until no new states are found, 
or until an unstable state is reached. This is the default option. </DD>
</DL>
<P>
 
<DL>

<DT><B>-sift 
</B> </DT>
<DD>Use sifting to dynamically reorder the BDD variables when performing 
BDD operations. Can save a lot of memory, but uses more time. </DD>
</DL>
<P>
 <P>
The following 
options control the optimization of the data structure that produces the 
<B>ssc </B> code. 
<DL>

<DT><B>-o1 </B> </DT>
<DD>After causality analysis is complete, optimize the BDDs 
for the FSM by applying sifting (changing the BDD variable ordering) and 
simplification (cofactoring with respect to the reachable states). Note 
that the simplification will have no effect if the <B>-inc </B> option is used. 
</DD>
</DL>
<P>
 
<DL>

<DT><B>-o2 </B> </DT>
<DD>After causality analysis is complete, optimize the structure of the 
resulting FSM (which is represented by BDDs) by removing redundant latches. 
</DD>
</DL>
<P>
 <P>
The following command is used for verification of single signals 
<DL>

<DT><B>-single 
</B> </DT>
<DD>Checks that for any reached state no single signal is emitted twice  
(default for sccheck). </DD>
</DL>
<P>
 <P>
The following option is used for testing the <B>sccausal 
</B> program. 
<DL>

<DT><B>-tvf </B> </DT>
<DD>Forces TVF computation and causality analysis even for acyclic 
circuits. Used for regression testing. </DD>
</DL>
<P>
 <P>
The following options allows to 
generate <B>BLIF </B> (<B>B </B>erkeley <B>L </B>ogic <B>I </B>nterchange <B>F </B>ormat) versions of the 
processed file:  <P>
 
<DL>

<DT><B>-cyclic_blif </B> </DT>
<DD>If the circuit is cyclic, generates the 
<B>BLIF </B> version before performing causal analysis. If a <I>basename </I> was specified 
using the <B>-B </B> option, then the name of this blif file will be cyclic_<I>basename 
</I>.ssc.blif, cyclic.blif otherwise. </DD>
</DL>
<P>
 
<DL>

<DT><B>-blif </B> </DT>
<DD>If the circuit is causal, generates 
the acyclic <B>BLIF </B> version after the causal analysis. If a <I>basename </I> was 
specified using the <B>-B </B> option, then the name of this blif file will be 
<I>basename </I>.blif, sccausal.blif otherwise. </DD>
</DL>
<P>
 <P>
The following option avoids interfacing 
with <B>XES </B> simulator: 
<DL>

<DT><B>-no_xes </B> </DT>
<DD>By default, when an error is detected, <B>XES 
</B> simulator is called to graphically display the error. This option avoid 
the call to <B>XES </B>. </DD>
</DL>
<P>
 <P>
The following option verifies the <B>sc </B> file without <B>ssc 
</B> code generation:  
<DL>

<DT><B>-check </B> </DT>
<DD>Performs causality analysis.  If the circuit 
is causal, checks that for any reached state no single signal is emitted 
twice.  Does not generate the <B>ssc </B> code. </DD>
</DL>
<P>
  
<H2><A NAME="sect4" HREF="#toc4">Optimization </A></H2>
Constructiveness 
analysis can be expensive.  The <B>-inc </B> option is usually the best for memory-intensive 
analysis, because the TVFs are computed only for the reachable states 
of the system.  However, in the case where an intermediate reached state 
set has a large BDD, it may not be efficient.  In addition, this option 
may require more time as each network-TVF computation is interleaved with 
a cofactor operation with respect to the reached-state set.  In general, 
for memory-intensive programs, <B>-inc </B> performs better than <B>-restrict </B>, which 
performs better than <B>-cofactor </B>.  The option <B>-sift </B> can be useful in all 
cases to reduce memory consumption. <P>
 For CPU-intensive programs, <B>-cofactor 
</B> performs better than <B>restrict </B> (they are nearly identical operations, 
but restrict must be applied to every node).  The <B>-inc </B> option is more difficult 
to predict.  It requires an application of cofactor at each iteration and 
hence may take longer; at the same time it uses (possibly) smaller BDDs 
which may be faster and compensate for the extra cost at each iteration. 
<P>
  
<H2><A NAME="sect5" HREF="#toc5">BUGS </A></H2>
The current version is under test, and as such, may exhibit anomalies. 
<P>
  
<H2><A NAME="sect6" HREF="#toc6">DIAGNOSTICS </A></H2>
If the input circuit is non-constructive, a counter-example 
input sequence is printed and the xes simulator is called to display the 
error graphically. <P>
  
<H2><A NAME="sect7" HREF="#toc7">SEE ALSO </A></H2>
Esterel documentation. The paper "Constructive 
Analysis of Cyclic Circuits" by T. Shiple, G. Berry, and H. Touati.  <P>
<A HREF="esterel1.html">esterel(1)</A>
, 
<A HREF="lcsc1.html">lcsc(1)</A>
, <A HREF="scssc1.html">scssc(1)</A>
  
<H2><A NAME="sect8" HREF="#toc8">IDENTIFICATION </A></H2>
Ecole des Mines de Paris (CMA) and INRIA 
Sophia-Antipolis.  <P>
Written by Tom Shiple &amp; Horia Toma &amp; Amar Bouali.  <P>
Based 
on the TiGeR BDD and FSM library, property of Digital Equipment Corp.  
and distributed by the XORIX company. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">OPTIONS</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Optimization</A></LI>
<LI><A NAME="toc5" HREF="#sect5">BUGS</A></LI>
<LI><A NAME="toc6" HREF="#sect6">DIAGNOSTICS</A></LI>
<LI><A NAME="toc7" HREF="#sect7">SEE ALSO</A></LI>
<LI><A NAME="toc8" HREF="#sect8">IDENTIFICATION</A></LI>
</UL>
<P><A HREF="index.html">Back To Main Manual Page</A><P>
</BODY></HTML>
