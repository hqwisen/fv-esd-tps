.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LUS2OC 1"
.TH LUS2OC 1 "2016-12-05" "lustre v4, release III.a" "Lustre V4 Distribution"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
lus2oc, ec2oc \- lustre to Lustre/Esterel Object Code
.SS "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
\&\fBlus2oc\fR \fIfile\fR\fB.lus\fR \fBnode\fR [\fBoptions\fR]
.PP
\&\fBec2oc\fR \fIfile\fR\fB.ec\fR [\fBoptions\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBlus2oc\fR command requires a file and a main node; it first calls
\&\fBlus2ec\fR to build the corresponding expanded code, then calls 
\&\fBec2oc\fR with all remaining options.
.PP
The \fBec2oc\fR command builds a sequential program structured as an
automaton. Several options allow the user to adjust the automaton
generation. 
The default target format is \fIoc version 5\fR,
but the version 2 is still supported, for compatibility with 
old tools. The default is to write the result in the file
"\f(CW\*(C`node.oc\*(C'\fR".
.SH "OPTIONS"
.IX Header "OPTIONS"
.SS "Miscellaneous"
.IX Subsection "Miscellaneous"
.IP "\fB\-v\fR" 4
.IX Item "-v"
set the verbose mode.
.IP "\fB\-help\fR" 4
.IX Item "-help"
print available options.
.IP "\fB\-default\fR" 4
.IX Item "-default"
print default options.
.IP "\fB\-o\fR \fIfile\fR\fB.oc\fR" 4
.IX Item "-o file.oc"
define the output file.
.IP "\fB\-pure\fR" 4
.IX Item "-pure"
implement Boolean inputs/outputs with \*(L"pure\*(R" signal (i.e. side-effects).
The default is to implement Boolean inputs/outputs 
with \*(L"classic\*(R" variables, just like integer or reals.
.IP "\fB\-double\fR" 4
.IX Item "-double"
implement the lustre type \fBreal\fR with the target type
\&\fBdouble\fR (the default target type is \fBfloat\fR).
.SS "Static optimization"
.IX Subsection "Static optimization"
.IP "\fB\-min\fR" 4
.IX Item "-min"
(default) the initial operator network is minimized before
code generation. This minimization is a kind of \*(L"common sub-expression
checking\*(R" except that the network may contain cycles; as a consequence
this phase can be expensive, so the user can disable it (cf. \fB\-nomin\fR).
.IP "\fB\-nomin\fR" 4
.IX Item "-nomin"
disable the minimization of the operator network (cf. \fB\-min\fR).
.IP "\fB\-const\fR" 4
.IX Item "-const"
perform static computation of constant expressions.
.SS "Output format"
.IX Subsection "Output format"
.IP "\fB\-oc2\fR" 4
.IX Item "-oc2"
generate an \fIoc V2\fR file.
.IP "\fB\-oc5\fR" 4
.IX Item "-oc5"
(default) generate an \fIoc V5\fR file.
.SS "Automaton"
.IX Subsection "Automaton"
The main control structure is an automaton, obtained by static simulation
of the Boolean variables (called state variables). The user can select the
set of state variables:
.IP "\fB\-0\fR" 4
.IX Item "-0"
no state variable; the resulting automaton has only one state. 
This mode is not supported if the source program contains clocks.
.IP "\fB\-1\fR" 4
.IX Item "-1"
only clocks are simulated. For single-clocked program, the
resulting automaton has always 2 states (the initial one and the
non-initial one).
.IP "\fB\-2\fR" 4
.IX Item "-2"
(default) all Boolean variables are simulated; the resulting
program is the \*(L"fastest\*(R" code that can be generated, but unfortunately
its size may be exponentially greater that the source code one. 
It it advisable to use the \fB\-v\fR option, in order to stop the compilation
if the automaton size grows too much.
.PP
The user may choose between two algorithms for the generation:
.IP "\fB\-data\fR" 4
.IX Item "-data"
(default) the data-driven algorithm simulates the Boolean
variables without taking into account their actual influence on the
outputs. The resulting automaton is in general non-minimal
according to the output computation.
.IP "\fB\-states\fR \fIinteger\fR" 4
.IX Item "-states integer"
works in data-driven mode. The generation
stops after the specified number of states (default 10000).
This limit avoids the generation of too huge code.
.IP "\fB\-demand\fR" 4
.IX Item "-demand"
the demand-driven algorithm builds a automaton just 
\&\*(L"big\*(R" enough to perform the computation of the outputs.
Using this option is quite equivalent to perform a standard minimization
on the automaton produced by the data-driven algorithm.
.PP
The user can select the way conditional statements are treated:
.IP "\fB\-S1\fR" 4
.IX Item "-S1"
forbid code duplication, i.e. tests are closed as soon as possible.
.IP "\fB\-S2\fR" 4
.IX Item "-S2"
(default) use an heuristic for opening/closing tests; it forbids
duplication of \*(L"big\*(R" parts of code.
.IP "\fB\-S3\fR" 4
.IX Item "-S3"
forbid test duplication, i.e. tests are closed only when they are
no longer needed.
.IP "\fB\-S4\fR" 4
.IX Item "-S4"
forbid test closing; this option is the worst one in term of
code size, but it can be very useful for analysing the program
(see in particular \fBlus2atg\fR).
.SS "Bdds"
.IX Subsection "Bdds"
The bdd (binary decision diagrams) library is one of the most
critical (time and space cost) 
part of the compiler. The user may change some parameters in order to improve
compilation time.
.IP "\fB\-merge\fR" 4
.IX Item "-merge"
perform a \*(L"clever\*(R" variable ordering before building bdds;
this option is sometimes useful when the state generation step
cannot even start.
.IP "\fB\-bddpage\fR \fIinteger\fR" 4
.IX Item "-bddpage integer"
the space devoted to bdds is allocated
by pages. Before allocating new pages, the program first performs
garbage collection; for big programs, frequent garbage collection may
dramatically slow down the compilation, so the user may increase
the size of pages, expressed in kilo-unit (default 10).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
lustre, lus2ec, ecexe, luciole, simec, lus2oc, ec2oc, ocmin, lus2atg, oc2atg,
ec2c, poc, lux, lesar, ecverif, xlesar
