<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;</span></strong></big>
</td></tr>
</table>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#TARGET-CODE">TARGET CODE</a>
    <ul>
      <li><a href="#Execution-context">Execution context</a></li>
      <li><a href="#Step-procedure">Step procedure</a></li>
      <li><a href="#Inputs-and-outputs">Inputs and outputs</a></li>
      <li><a href="#Example">Example</a></li>
      <li><a href="#External-objects">External objects</a></li>
      <li><a href="#Standard-main-loop">Standard main loop</a></li>
      <li><a href="#Pragmas">Pragmas</a></li>
    </ul>
  </li>
  <li><a href="#OPTIONS">OPTIONS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>ec2c, poc - ansi C code generator</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p><b>ec2c</b> <i>file</i><b>.ec</b> [<b>options</b>]</p>

<p><b>poc</b> <i>file</i><b>.oc</b> [<b>options</b>]</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>These tools are Ansi-C code generators. They are presented together, since they share the same conventions for the generated user interface. Otherwise, they are completely separated tools, working in different formats, and performing different tasks:</p>

<ul>

<li><p><b>poc</b> takes as input a <b>oc</b> file, which is already a sequential imperative program; the work of <b>poc</b> is then a simple translation between similar formalisms.</p>

</li>
<li><p><b>ec2c</b> compiles an <b>ec</b> program into Ansi-C code. Since <b>ec</b> (which is a subset of Lustre) is a declarative language, a lot of work remains to do for building sequential code. In this sense, <b>ec2c</b> is closer (but anyway simpler) to a tool like <b>ec2oc</b>. Roughly speaking, using <b>ec2c</b> is almost equivalent to using <b>ec2oc</b> with the <b>-0</b> option, and then <b>poc</b>. The main characteristic of this compiler is that both the compilation time and the size of the code are linear with respect to the size of the source code. Moreover the compilation algorithm strictly follows the Lustre formal semantics, just like the simulator <b>ecexe</b> does.</p>

</li>
</ul>

<h1 id="TARGET-CODE">TARGET CODE</h1>

<p>The code generated by those compilers consists essentially in a procedure implementing a step of the reactive program described in the source file. In order to run the reactive program, the user must write a main loop around the &quot;step&quot; procedure.</p>

<p>In the following, we precise what it is automatically generated, and what the user has to write. Let us call <i>foo.oc</i> (resp. <i>foo.ec</i>) the source file, <i>FOO</i> the <b>oc</b> module (resp. the <b>ec</b> node) defined in the source file, <i>foo.c</i> and <i>foo.h</i> the generated files, and <i>loop.c</i> the main program written by the user.</p>

<h2 id="Execution-context">Execution context</h2>

<p>The generated code allows multiple allocations of a reactive module. The memory needed for an instance of the reactive module is defined in <i>foo.c</i>, and declared in <i>foo.h</i>:</p>

<pre><code>        struct FOO_ctx;</code></pre>

<p>The user does not have to know what this structure is made of, he is only allowed to manipulate pointers. The user can get a new context using a procedure declared in <i>foo.h</i>:</p>

<pre><code>        struct FOO_ctx * FOO_new_ctx(void* client_data);</code></pre>

<p>The user can associate an extra information to a new execution context using the <code>client_data</code> argument. This information is necessary if the user wants to run several instances of a same reactive module concurrently.</p>

<h2 id="Step-procedure">Step procedure</h2>

<p>The procedure implementing a step of the reactive module is declared in <i>foo.h</i>:</p>

<pre><code>        void FOO_step(struct FOO_ctx * ctx);</code></pre>

<p>This procedure is called with an execution context previously created by a call to <code>FOO_new_ctx</code>. This step procedure has no input/output parameters, since communication between the main loop and the reactive module is made via input/output procedures. More precisely, the user must call input procedures to set the input values before he calls the step procedure. The step procedure calls output procedures to send its outputs to the environment.</p>

<h2 id="Inputs-and-outputs">Inputs and outputs</h2>

<p>Communications between <i>foo.c</i> and <i>loop.c</i> are made via input and output procedures. The input procedures are defined in <i>foo.c</i> and used in the main loop, the output procedures are defined by the user (in <i>loop.c</i> for instance), and used in <i>foo.c</i>.</p>

<p>For each input <b>IN</b>, of type <b>TYP</b>, <i>foo.c</i> contains the definition of the procedure:</p>

<pre><code>        void FOO_I_IN(struct FOO_ctx* context, TYP value);</code></pre>

<p>Note that if <b>IN</b> is a pure signal (<b>poc</b> only), the <i>value</i> parameter is omitted:</p>

<pre><code>        void FOO_I_IN(struct FOO_ctx* context);</code></pre>

<p>For each output <b>OUT</b>, of type <b>TYP</b>, the user must define a procedure:</p>

<pre><code>        void FOO_O_OUT(void* client_data, TYP value);</code></pre>

<p>Note that if <b>OUT</b> is a pure signal (<b>poc</b> only), the <i>value</i> parameter is omitted:</p>

<pre><code>        void FOO_O_OUT(void* client_data);</code></pre>

<p>Output procedures are called within <b>FOO_step(FOO_ctx* ctx)</b>, using the client data which has been associated with <b>ctx</b> when it was created.</p>

<h2 id="Example">Example</h2>

<p>Here is a simple example of a main loop using a reactive module (whose name is <code>sum</code>) with two real inputs (<code>x</code> and <code>y</code>) and a single real output <code>s</code>; note that the <i>client data</i> is not necessary, since the loop uses only one instance of the reactive module:</p>

<pre><code>        #include &lt;stdlib.h&gt;
        #include &quot;sum.h&quot;

        void sum_O_s(void* cdata, float _V){
           printf(&quot;result: %f\n&quot;, _V);
        }

        main(){
           _float x;
           _float y;
           struct sum_ctx* prg = sum_new_ctx(NULL);
        
           while(1){
              printf(&quot;(float) x ?\n&quot;);
              scanf(&quot;%f&quot;, &amp;x);
              sum_I_x(prg, x);
              printf(&quot;(float) y ?\n&quot;);
              scanf(&quot;%f&quot;, &amp;y);
              sum_I_y(prg, y);
              sum_step(prg);
           }
        }</code></pre>

<h2 id="External-objects">External objects</h2>

<p>Each external object declared in the source file is supposed to be implemented by the user. Some information is necessary for the compilation of the <b>c</b> generated code, other is necessary only for linking.</p>

<ul>

<li><p><b>Compiling</b> The <i>foo.c</i> program generated by <b>poc</b> cannot be compiled unless the external types are defined. <b>poc</b> supposes that those definitions are in a file called <i>foo_ext.h</i>.</p>

</li>
<li><p><b>Linking</b> External constants, functions and procedures are declared in <i>foo.c</i> as imported objects, so <i>foo.c</i> can be compiled separately. Indeed the user must define those objects somewhere, and link the corresponding code with the <b>poc</b> object code if he wants to build an executable program!</p>

</li>
</ul>

<h2 id="Standard-main-loop">Standard main loop</h2>

<p>When called with the <b>-loop</b> option, <b>poc</b> (resp. <b>ec2c</b>) produces an extra c-file <i>FOO_loop.c</i>. This code contains a main procedure implementing a loop which reads inputs on <b>stdin</b> and write outputs to <b>stdout</b>. If <i>foo.c</i> does not need external object, it is a simple way to obtain executable code. For instance:</p>

<pre><code>        poc sum.oc -loop
        gcc sum.c sum_loop.c -o sum</code></pre>

<p>produces an interactive program <b>sum</b>, which allows the user to test his code.</p>

<p>If external objects are needed, the user must write all the necessary code plus two procedures for each external type <b>TYP</b>:</p>

<ul>

<li><p><code>TYP _get_TYP(char* name)</code> reads a value of type <b>TYP</b> on <b>stdin</b>, and returns it. The argument &quot;<code>name</code>&quot; is the name of the input, used to make the procedure more &quot;interactive&quot;.</p>

</li>
<li><p><code>void _put_TYP(TYP val)</code> prints the value &quot;<code>val</code>&quot; on <b>stdout</b>.</p>

</li>
</ul>

<h2 id="Pragmas">Pragmas</h2>

<p>In order to allow automatic manipulation of the code generated, the compiler generates special comments (pragmas) in the header file. Pragmas are single line Ansi C comments, begining with the string <b>poc:</b>. Ther is a pragma which gives the name of the module, and a pragma for each input and each output, giving its type and its name. Here is an example of pragma section:</p>

<pre><code>        //poc:MODULE sum 
        //poc:IN _float x
        //poc:IN _float y
        //poc:OUT _float s</code></pre>

<h1 id="OPTIONS">OPTIONS</h1>

<dl>

<dt id="v"><b>-v</b></dt>
<dd>

<p>set the verbose mode.</p>

</dd>
<dt id="o-name"><b>-o</b> <i>name</i></dt>
<dd>

<p>define the prefix for the target files. The default is to use the name of the module (i.e. node), which is not necessarily the name of the source file.</p>

</dd>
<dt id="loop"><b>-loop</b></dt>
<dd>

<p>generate an extra main file called <i>name</i><b>_loop.c</b>. This main is sufficient to build a stand-alone application if the reactive module does not need any external definitions.</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>lustre, lus2ec, ecexe, luciole, simec, lus2oc, ec2oc, ocmin, lus2atg, oc2atg, ec2c, poc, lux, lesar, ecverif, xlesar</p>

<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;</span></strong></big>
</td></tr>
</table>

</body>

</html>


