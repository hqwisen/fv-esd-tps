<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;</span></strong></big>
</td></tr>
</table>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Lustre-and-ec">Lustre and ec</a></li>
      <li><a href="#Simulation">Simulation</a></li>
      <li><a href="#Automata-generation">Automata generation</a></li>
      <li><a href="#C-code-generation">C code generation</a></li>
      <li><a href="#Formal-verification">Formal verification</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>lustre</p>

<p>lus2ec, ecexe, luciole, simec, lus2oc, ec2oc, ocmin, lus2atg, oc2atg, ec2c, poc, lux, lesar, ecverif, xlesar - lustre v4 tools</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<h2 id="Lustre-and-ec">Lustre and ec</h2>

<p>The front-end for Lustre-V4 tools is the pre-processor <b>lus2ec</b></p>

<p>This compiler transforms a Lustre-V4 program (<b>.lus</b> file, with modularity, arrays, recursion) into a Lustre-expended-code program (<b>.ec</b> file, with a single node, no arrays, no recursion).</p>

<p>All other tools (compilers, simulators ...) are actually running on the <b>.ec</b> format, but the distribution provides (in general) shell scripts combining the front-end (<b>lus2ec</b>) with the various back-ends (compilers and simulators).</p>

<h2 id="Simulation">Simulation</h2>

<p>The Lustre-V4 distribution provides simulation tools that interpret <b>ec</b> code. They only run on <i>basic programs</i>, that do not require external types, constants or functions; however, some classical functions are supported, corresponding to the <i>math</i> C library. All those tools are based on the same interpreter, and only differ on the user interface:</p>

<dl>

<dt id="File-to-file-simulation"><b>File to file simulation:</b></dt>
<dd>

<p><b>ecexe</b> is a <i>unix-filter like</i> tool, reading on standard input and writing to standard output.</p>

</dd>
<dt id="Graphical-simulation"><b>Graphical simulation:</b></dt>
<dd>

<p><b>xecexe</b> (script <b>xsimlus</b>) provides a graphical interface to the <b>ec</b> interpreter; this tool, based on X-intrinsics and Athena widgets is quite old and no longer maintained.</p>

<p><b>simec</b> (script <b>luciole</b>) provides a more friendly interface, based on <i>tcl-tk widgets</i>. Moreover, it allows the user to (slightly) customize the graphical interfaces.</p>

</dd>
</dl>

<h2 id="Automata-generation">Automata generation</h2>

<p>Originally, the lustre compiler was designed to use an intermediate format, called <b>oc</b> (for object code). This format was initiated by a collaboration with the Esterel team, and several releases where defined. The main characteristic of this format is that the control structure consists of a finite state automaton. The tool <b>ec2oc</b> (script <b>lus2ec</b> or <b>lustre</b>) supports <b>oc</b> version 2 ( <b>oc2</b>) and 5 (<b>oc5</b>). It also provides lot of options that allow the user to choose the automaton stucture of the generated code.</p>

<p>Some tools based on the <b>oc</b> format are provided by the Esterel team, in particular C and Ada code generators (<b>occ</b>, <b>ocada</b>). An alternative Ansi-C code generator, <b>poc</b>, is provided within the lustre distribution.</p>

<p>The distribution also provides a tool that performs minimization of oc automata (<b>ocmin</b>) and a translator to the <i>autograph</i> format (<b>oc2atg</b>).</p>

<h2 id="C-code-generation">C code generation</h2>

<p>The low-level target format in Lustre-V4 is Ansi-C. This code can be obtained either:</p>

<ul>

<li><p>via <b>ec2oc</b>, using the <b>poc</b> compiler,</p>

</li>
<li><p>directly from the <b>ec</b> code, using the compiler <b>ec2c</b>.</p>

</li>
</ul>

<p>Note that the code generated by <b>ec2c</b> is different from the one generated by <b>ec2oc</b>; in particular <b>ec2c</b> does not build any kind of automaton. On the contrary the generated interface is the same for both compiler, so one can (normally) easily swap between code generated by <b>poc</b> and code generated by <b>ec2c</b>.</p>

<p>By default, those compilers only provide a <i>transition function</i>, and the user has to write his (her) own input/output and main procedures. Moreover, the user has to provide the implementation of all external objects (types, constants and functions) declared in the Lustre source.</p>

<p>Nevertheless, both <b>poc</b> and <b>ec2c</b> have an option <b>-loop</b> that builds an additional main procedure. This simple &quot;loop&quot; works as a unix filter (just like <b>ecexe</b>). In order to obtain an executable, this main program may be completed by the implementation of the (possible) external objects. Anyway, it can be used as a pattern for more complex application.</p>

<p>If the code does not require external objects, the main generated by the <b>-loop</b> option can be linked &quot;as it is&quot; with the transition function, in order to build a stand-alone application. This is the case for almost all programs that can be simulated using <b>ecexe</b>; by the way, the execution of such a stand-alone program is completly similar to a simulation with <b>ecexe</b>: standard input to standard output, interactive when called form a terminal.</p>

<p>The script <b>lux</b> is the best way for quickly building a stand-alone application: it can take either <b>lus</b>, <b>ec</b> or <b>oc</b> files as input, and uses the most suitable compilers calls and build, if possible, a sstand-alone application. Note that C compilation and the link-editing are performed by the host Ansi-C compiler; by default, <b>lux</b> calls the GNU C compiler <b>gcc</b>, but one may customize this script.</p>

<h2 id="Formal-verification">Formal verification</h2>

<p>The Lustre model-checker is <b>ecverif</b> (shell <b>lesar</b>). It provides several algorithms to check the validity of safety properties on Lustre programs. <b>lesar</b> (resp. <b>ecverif</b>) takes as input special <b>lustre</b> (resp. <b>ec</b>) programs, called <i>verification programs</i>. Roughly speaking, such a program must be the parallel product of a program to validate, a program <i>observing</i> that the desired property is satisfied, and another one <i>observing</i> that the hypothesis on the environment are satisfied. The user may build this product himself, and at last, <b>lesar</b> only checks that its input has a single Boolean output, wich is supposed to be the property to check; the hypothesis are supposed to be the conjunction of all the assertions appearing in the verification program.</p>

<p><b>xlesar</b> is a graphical interface to <b>lesar</b>/<b>ecverif</b>. This tool is particularly suitable for managing a set of verifications on the same Lustre programs.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>lustre, lus2ec, ecexe, luciole, simec, lus2oc, ec2oc, ocmin, lus2atg, oc2atg, ec2c, poc, lux, lesar, ecverif, xlesar</p>

<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="_podblock_" style="background-color: #cccccc; color: #000" valign="middle">
<big><strong><span class="_podblock_">&nbsp;</span></strong></big>
</td></tr>
</table>

</body>

</html>


